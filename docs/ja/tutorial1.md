# チュートリアル(1): インストールおよび基本的な使い方

cspuz は，CSP ソルバーに基づいたパズルソルバーを作成するための Python ライブラリです．
cspuz を利用すると，次のようなことが可能になります：

- 直感的なインタフェースを用い，CSP ソルバーを Python から直接利用する
- 多くのパズルのソルバーを簡単に記述する

cspuz それ自体は CSP ソルバーを含みません．代わりに，外部の CSP ソルバーへのインタフェースを提供します．
cspuz では CSP ソルバー [Sugar](http://bach.istc.kobe-u.ac.jp/sugar/) を利用することができます．

## cspuz のインストール

先述のように，cspuz は CSP ソルバー [Sugar](http://bach.istc.kobe-u.ac.jp/sugar/) を呼び出して利用します．そのため，cspuz をインストールするためには，予め Sugar をインストールしておく必要があります．Sugar のインストール方法については，Sugar のホームページを参照してください．

Sugar をインストールしたら，次に cspuz をインストールします．

1. `https://github.com/semiexp/cspuz` を clone します．
2.  clone したディレクトリで `pip install .` を実行します．

Tips: cspuz は Python2 では恐らく動作しません．`python` コマンドで Python2 が起動する場合は，デフォルトの Python が Python3 系列になるようにしておくか，`python`, `pip` をそれぞれ `python3`, `pip3` に読み替えるなどしてください．

これで cspuz 自体のインストールは完了です．
ただし，実際に cspuz を Python から使用する際には，Sugar のパスを指定しておく必要があります．
そのため，環境変数 `$CSPUZ_BACKEND_PATH` に `sugar` スクリプト（Sugar に含まれているはずです）のパスを指定してください．

### `sugar-ext` バックエンドの利用

(TODO: 英語版の説明 https://github.com/semiexp/cspuz/blob/master/README.md を見てください)

## cspuz で CSP を解く

cspuz で CSP を解く手順は次のようになります：

- クラス `cspuz.Solver` のインスタンス (solver) を生成する
- CSP の変数定義を行う
- 定義した変数に対する制約を solver に与える
- `solver.find_answer()` や `solver.solve()` を用いて CSP を解く

これらの手順を，実際の Python コードを示しつつ説明していきます．
以下，Python の対話環境（`python` コマンドを引数なしで呼び出すと起動します）を前提とします．

初めに，`cspuz` を import します：
```
>>> import cspuz
```

solver の生成は次のようにすればよいです：
```
>>> solver = cspuz.Solver()
```

CSP の変数定義はこの `solver` を介して行います．
```
>>> x = solver.bool_var()
>>> y = solver.int_var(0, 5)
>>> z = solver.int_var(3, 4)
```

`bool_var()` は真偽値を表す変数を新しく生成します．
`int_var(lo, hi)` は `lo` 以上 `hi` 以下の整数を表す変数を新しく生成します．
これらの関数は呼び出すたびに異なる変数を生成します．

なお，同時に複数の solver を宣言することもできますが，どの変数がどの solver に対応するかのチェックは行われないため注意してください（混同すると誤動作します）．

次に，変数に対する制約を solver に与えます．
簡単に言うと，制約を Python の式みたいに書き，それを引数に `solver.ensure()` を呼び出せばよいです．詳細は後述します．

```
>>> solver.ensure(y + y == z)
>>> solver.ensure(x == (y > z))
```

最後に CSP を解きます．
与えた制約すべてを満たす変数の割当が存在するかを判定するには，`solver.find_answer()` を呼び出します．

```
>>> solver.find_answer()
True
```
`True` が返ってきました．これは割当が存在することを表します．
実際の割当は，各変数のインスタンス変数 `sol` を参照することで確認できます：
```
>>> x.sol
False
>>> y.sol
2
>>> z.sol
4
```
これは，得られた割当において `x = False, y = 2, z = 4` であったことを表します．実際，これが最初に与えた制約を満たすことはすぐに確かめられます．

## `solver.solve()` を用いて問題を「解ける限り」解く

前節では `solver.find_answer()` を使って CSP の解を 1 つ求めました．
ところで，実際にパズルソルバーを作成する際には，「解ける限り」解く，すなわち「絶対にその値を割り当てないといけない，という値だけ確定させる」ことが重要になることがあります．
そのために `solver.solve()` を使うことができます．

ここでは，例として前節と違う問題を用います．

```
>>> solver = cspuz.Solver()
>>> x = solver.int_var(1, 3)
>>> y = solver.int_var(1, 3)
>>> z = solver.int_var(1, 3)
>>> solver.ensure(cspuz.alldifferent(x, y, z))
>>> solver.ensure(x + y == 3)
```

3 つの変数 `x`, `y`, `z` があり，いずれも 1 以上 3 以下の整数で，互いに異なっています．また，`x + y = 3` です．
これを満たす割当は `(x, y, z) = (1, 2, 3), (3, 2, 1)` の 2 つがあります．いずれにしても `z = 3` が確定しますが，`x`, `y` の値は確定しません．

`solver.solve()` を使うためには，呼び出す前に「確定させるべき変数」を `solver.add_answer_key()` により solver に登録する必要があります．
登録されなかった変数は確定させる必要はないとみなされ，仮に確定させられるとしても試行が行われません．
（実際にパズルソルバーを書く際には，答えには直接関係はないが CSP として記述するために必要な変数が現れることが多々あり，そのような変数に対しても確定を試みるのはコストが大きいため，このような仕様になっています．）

```
>>> solver.add_answer_key([x, y, z])
```
（現状，単一の変数か，変数の iterable のみ与えることができます．`solver.add_answer_key(x, y, z)` と書くことはできません）

この上で `solver.solve()` を呼び出してみましょう：
```
>>> solver.solve()
True
```
この `True` は `find_answer()` のときと同様，制約をすべて満たす変数の割当が存在することを表します．
実際の割当結果も確認してみましょう：
```
>>> print(x.sol, y.sol, z.sol)
None None 3
```
`x.sol` および `y.sol` が `None` となりました．これは，値を確定させることができなかったことを表します．
一方，`z.sol` は `3` となっており，値が 3 に確定することを表します．
先程確認したように，この問題においては `x`, `y` の値は確定せず，`z` の値のみが 3 に確定するため，正しい結果が得られました．

## cspuz での制約の記述

制約を書くために使える演算子には次のものがあります．

- 加算 `+`, 減算 `-`（`-` は単項演算子としても使えます）
- 比較演算 `==`, `!=`, `<`, `>`, `<=`, `>=`（`==`, `!=` は真偽値に対しても使えます）
- 論理積 (and) `&`, 論理和 (not) `|`, 否定 (not) `~`

演算子のオペランドの片方が通常の Python の `bool` や `int` の値であってもかまいません．例えば `a + 2 < b` と書くことができます．

論理演算子 `&`, `|`, `~` は通常 Python で用いる `and`, `or`, `not` とは異なっていることに注意してください．
また，これらの演算子の優先順位は `<` などより高いため，例えば次のようには書けません：
```
a < b | b < a + 3
```
代わりに次のように書くべきです：
```
(a < b) | (b < a + 3)
```

また，次のようなものもあります：
- 「`x` ならば `y`」を意味する `x.then(y)`
- 論理値 `b` に対して，`x if b else y` に対応する `b.cond(x, y)`
- 引数に与えた変数がすべて異なることを意味する `cspuz.alldifferent`
